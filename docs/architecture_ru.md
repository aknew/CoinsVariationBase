Приложение построено с применением библиотеки qt, его [визуальный интерфейс](#GUI) написан при помощи языка qml (и в дальнейшем вся работа с GUI будет полностью реализована в нем), а [бекэнд](#backend) реализован на c++. Данные хранятся в виде специальной папки (см. раздел [Хранение информации](#Хранение информации), в целом считается что почти весь интерфейс может быть построен динамически на основании файла struct.json из этой папки. Хотелось бы отметить что поскольку данный проект начал писаться еще во времена qt 4.7 и собрал немало костылей за время своего написания, некоторые моменты в описании касательно невозможности сделать те или иные вещи в qt могут быть устаревшими. 


#backend

Все имеющиеся в базе таблицы можно разделить на два типа:

* Независимая таблица, может показываться сама по себе, имеет переходы на следующий уровень, также может иметь разные представления для списка и для конкретной записи (например, в  списке все признаки аверса сливаются в одну строку, а в конкретной записи показываются по отдельности). Также именно в ее ведении все управение подчиненными табличками
Умеет:
-выдавать модель для отображения
-получать и выбирать по ид запись и представлять ее в виде json в поняти записи входят также подчиненные модели
-копировать запись включая подчиненные модели

* Подчиненая таблица, например, ссылки на источники, не показываются отдельно от своей главной таблицы. Используются основной таблицей для получения списка и для внесения изменений

Бекэнд приложения состоит из следующих классов и модулей:

**CVBController** - основной класс для взаимодействия между GUI и бекэндом, в qml представлен синглтоном с именем CVBApi из пакета CVB.api . Является мостиком между GUI и хранилищем данных\настройками\парсинг struct.json и т.п.

**CVBTranslator** - можуль-локализатор, крайне прост и написан исключительно потому что родной QTranslator (наследником которого он является) работает с встроенными в программу на этапе компиляции переводами, а мне нужны были динамически подгружаемые из файла. Переводы грузит из json, причина - так было написать быстрее всего

**CVBImageProvider** - провайдер изображений, наследник QQuickImageProvider.

**CVBBaseProvider** - основной класс по работе с БД. Во многом его функции могли бы быть перенесены на CVBController, со временем возможно так и сделаю. Во многом реликт времен интерфейса на qwidgets

**CVBSqlNode** - описание узла данных, содержит имя таблицы, куда из нее можно перейти и некоторые данные для построения интерфейса.

**CVBSqlRelationalTableModel** - класс для отображения модели в qml. На самом деле мне не нужен потомок QSqlRelationalTableModel, но при использовании QSqlTableModel у меня возникли проблемы - см. мой вопрос на [stackoverflow](http://stackoverflow.com/questions/14613824/qsqltablemodel-inheritor-and-qtableview). Также там есть пара нужных мне методов, таких как генерация json для отображения записи в qml и сортировки по названию столбца

**comboboxdescription** - класс-описание всплывающих списков - откуда брать значения и как их фильтровать

**CVBUtils** - небольшой модуль, служащий для сборки воедино всяких мелких утилит. В данный момент представлен всего одной функцией преобразования пути файла из представления qml в представление qt c++


# GUI

GUI выполнен при помощи языка qml. Основной компонент (MainWindow.qml) представляет собой окно из верхнего таббара и stackview? в который загружаются отображающие данные виды. Эти виды генерятся динамически на основании данных из struct.json или прямо из данных о таблице если в struct.json ничего не определено и бывают двух типов:

* ListView - отображает список записей при помощи CVBSqlRelationalTableModel, не содержит возможности непосредственного редактирования (вставка и удаление осуществляется при помощи обращения к полной форме конкретной записи)

* FullInformationViews - полной форме конкретной записи, строится автоматом на основе списка полей и их типов, может быть отредактирована. В качестве носителя данных вытпает json-объект который генерится из записи классом CVBSqlNode и помимо полей собственно записи включает в себя еще и ссылающиеся на эту запись данные из подчиненных таблиц.

Вообще говоря имеется возможность использовать предварительно подготовленную qml для отображения видов, но это скорее артефакт более ранней версии и будет ли использоваться в дальнейшем еще не решил

# Хранение информации

Хранение информации реализовано в виде папки на диске со следующей структурой:

```
├───attachment
│   ├───note1.pdf
│   └───note2.doc
├───images
│   ├───1.bmp
│   └───2.jpg
├───languages
│   └───ru_RU.json
├───base.sqlite
└───struct.json
```

**attachment** - папка с вложениями, вложения могут быть любыми (с оговоркой что хорошо бы что-то не слишком экзотическое чтобы со временем сделать экспорт) и открываются во внешних программах. Назначение данной сущности - нечто наподобие заметок, например, статья как отличать монеты Елизаветы разных дворов друг от друга или скан заключения ГИМа. Возможно, со временем будет возможность делать ко множеству сущностей (типов-вариантов) одно вложение

**images** - папка с картинками, в целом аналогичны вложениям (как видно из диаграмы, таблицы в базе имеют одинаковую структуру), но будут показываться прямо в программе. В качестве идентификатора в таблице и имени будет md5-сумма файла

**languages** - папка с переводами. Не то чтобы я пытался замахнуться на продукт с международным использованием, просто проще всего сматчить названия полей в таблице на английском прямо в название полей в интерфейсе чем делать отдельно подписи и следить чтобы ничего не перепуталось.

**base.sqlite** - основное хранилище данных, база sqlite

**struct.json** - заданет связи таблиц друг с другом и некоторые другие нужные для ГУЯ вещи (откуда брать данные для комбобоксов, что выводить в списке и т.п.). Причина пояления - хотелось менять некоторые параметры без перекомпиляции программы, пока не знаю сохранится ли он в дальнейшем

## Структура БД

При создании базы практически не были использованы триггеры и перенос повторяющихся данных в отдельные таблицы - на мой взгляд, слишком небольшой объем базы в целом и этих данных чтобы так усложнять структуру, особенно учитывая отсутствие переменных в тригерах sqlite и во что из-за этого превращается их код

Диаграмма сделана при помощи [DbVisualizer](http://www.dbvis.com/) и лежит рядом. Ниже перечисляю таблицы с их описанием, поля названы более-менее адекватно и потому описывать буду только что-то не очевидное. Если не указано иное - перед нами основная таблица

**Types** - если можно так выразиться, данная таблица это точка входа в базу, именно с нее и начинается вся работа. Она содержит в себе список монетных типов и их описание. Единственное неочевидное поле это issue - тип выпуска: "общегосударственный", "сибирская монета" и т.п.

**Variaties** - разновидности монет, varityType это тип разновидности - обычная, ложная (например, случайно получившаяся из-за выкрошки дата когда монет не чеканили), фальшивка, фуфло, новодел, спорная (используется когда не вполне понятнл что это - причуда выкрошки, подделка или еще что). ~~Таблица не содержит описания аверсов-реверсов т.к. они описаны в следующих таблицах~~

~~**ReversAttribute** и **AversAttribute** - описание особенностей аверсов и реверсов в виде длинного списка ключ-значение, например, \["орел":"обр. 1730";"на короне":"навершие от скипетра";"крест державы":"простой"\] . По хорошему надо сделать доптаблицу для каждой чтобы, во-первых, не вовторять по многу раз одно и то же, а, во-вторых, иметь возможность комментировать или же добавлять картинку для конкретной черты для наглядности, но это когда-нибудь потом~~ сейчас таких таблиц в поле нет, данная информация включена в Variaties в виде текстовых полей. Причина - переусложнение базы при том что почти того же можно добиться просто перечисляя признаки чере точку с запятой

                            
**ConcreteCoins** - список монет (конкретных экземпляров). Поле status это грубо говоря то где сейчас монета и что она в базе делает, лежит в коллекции, в обменном фонде или же просто что-то интересное и это "архивная" запись

**CoinHistory** - провенанс, откуда есть пошла монета

**SourcesList** - ссылка на возможные источники

**varReferences** - ссылка на каталоги и прочие источники для монеты в виде источник - номер -редкость -комментарий. Подчиненная таблица

**Features** - это интересные особенности которыми может обладать определенная монета и которые могут идти дополнением к разновидностям, пример таких особенностей - перечекан из рамки или гладкий гурт у денег обр. 1730, дробный перечекан у двушек в 1770-х. Не сложно понять что включение особенности именно в эту таблицу, а не в описание конкретной монеты носит субьективный характер, само же наличие таблицы несет под собой желание как-то подсветить ту или иную особенность. Для себя я выделяю следующие причины для включения:

* Включение монеты в каталоги в качестве отдельной разновидности, пример - уже упомянутый гладкий гурт на деньгах - есть почти во всех каталогах хотя по сути является браком и может быть дополнением к абсолютно любой другой разновидности
* Желание подсветить определенный факт носящий элемент случайности, примеры - дробный перечекан или перечекан ВРП на боратинке, при этом перечекан копеек из шведов сюда не попадает т.к. носит массовый характер и жестко завязан на определенные разновидности

От данной таблицы можно перейти к конкретным монетам (эта связь задана таблицей **CoinFeature**), но нельзя их добавить - у монеты всегда должна быть главная разновидность из таблицы Variaties

**Images** и **Notes** - таблицы с картинками и вложениями, связь с прочими данными задается в программе (не в базе) через поля relid и table, так странно чтобы не плодить сущности - иначе надо таких таблиц делать много

~~**FullReversDescription**, **FullAversDescription** и **FullVariatiesView** - служебные представления, первые два склеивают описание аверса или реверса в одну строку из кучи пар, третье выбирает их для варианта. Служат для отображения красивого списка.~~

В качестве идентификатора в большинстве таблиц используются GUID'ы чтобы модно было безболезнено сливать данные от разных источников. Исключением являются:

* Список источников - в качестве идентификатора используется человекочитаемое сокращение, например, "ВКГМ" или "Уздеников"
* Картинки - используют хеш-сумму в качестве идентификатора и названия

# struct.json

