Приложение построено с применением библиотеки qt, его [визуальный интерфейс](#gui) написан при помощи языка qml (и в дальнейшем вся работа с GUI будет полностью реализована в нем), а [бекэнд](#backend) реализован на c++. Данные хранятся в виде специальной папки (см. раздел [Хранение информации](#Хранение-информации), в целом считается что почти весь интерфейс может быть построен динамически на основании файла struct.json из этой папки. Хотелось бы отметить что поскольку данный проект начал писаться еще во времена qt 4.7 и собрал немало костылей за время своего написания, некоторые моменты в описании касательно невозможности сделать те или иные вещи в qt могут быть устаревшими. 


#backend

Все имеющиеся в базе таблицы можно разделить на два типа:

* Независимая таблица, может показываться сама по себе, имеет переходы на следующий уровень, также может иметь разные представления для списка и для конкретной записи (например, в  списке все признаки аверса сливаются в одну строку, а в конкретной записи показываются по отдельности). Также именно в ее ведении все управение подчиненными табличками
Умеет:
-выдавать модель для отображения
-получать и выбирать по ид запись и представлять ее в виде json. В понятие записи входят также подчиненные модели
-копировать запись включая подчиненные модели

* Подчиненая таблица, например, ссылки на источники, не показываются отдельно от своей главной таблицы. Используются основной таблицей для получения списка и для внесения изменений

Для управления их взаимодействием вводится понятие узла (ноды), который соотвествует определенной таблице, а также знает какие у нее подчиненные таблицы и куда можно с нее перейти

Бекэнд приложения состоит из следующих классов и модулей:

**CBController** - основной класс для взаимодействия между GUI и бекэндом, в qml представлен синглтоном с именем CBApi из пакета CB.api . Является мостиком между GUI и хранилищем данных\настройками\парсинг struct.json и т.п.

**CBTranslator** - можуль-локализатор, крайне прост и написан исключительно потому что родной QTranslator (наследником которого он является) работает с встроенными в программу на этапе компиляции переводами, а мне нужны были динамически подгружаемые из файла. Переводы грузит из json, причина - так было написать быстрее всего

**CBImageProvider** - провайдер изображений, наследник QQuickImageProvider.

**CBBaseProvider** - основной класс по работе с БД, отвечает за подключение к конкретной базе

**CBNode** - описание узла данных, содержит имя таблицы, куда из нее можно перейти и некоторые данные для построения интерфейса.

**CBSqlRelationalTableModel** - класс для отображения модели в qml. На самом деле мне не нужен потомок QSqlRelationalTableModel, но при использовании QSqlTableModel у меня возникли проблемы - см. мой вопрос на [stackoverflow](http://stackoverflow.com/questions/14613824/qsqltablemodel-inheritor-and-qtableview). Также там есть пара нужных мне методов, таких как генерация json для отображения записи в qml и сортировки по названию столбца

**CBUtils** - небольшой модуль, служащий для сборки воедино всяких мелких утилит. В данный момент представлен всего одной функцией преобразования пути файла из представления qml в представление qt c++


# GUI

GUI выполнен при помощи языка qml. Основной компонент (MainWindow.qml) представляет собой окно из верхнего таббара и stackview? в который загружаются отображающие данные виды. Эти виды бывают двух типов:

* ListView - отображает список записей при помощи CVBSqlRelationalTableModel, не содержит возможности непосредственного редактирования (вставка и удаление осуществляется при помощи обращения к полной форме конкретной записи)

* FullInformationViews - полной форме конкретной записи, строится автоматом на основе списка полей и их типов, может быть отредактирована. В качестве носителя данных вытпает json-объект который генерится из записи классом CVBSqlNode и помимо полей собственно записи включает в себя еще и ссылающиеся на эту запись данные из подчиненных таблиц.

Виды генерятся динамически на основании данных из struct.json или прямо из данных о таблице если в struct.json ничего не определено. Также виды могут быть загружены из заранее подготовленного файла, что сделано для случая когда вид содержит нечто специфическое, что не хотелось бы реализовывать при помощи абстраций или дополнительных параметров, например, я хочу подсвечивать ячейку разновидности определенным цвет в зависимости от того что перед намим - обычная разновидность, фальшак, новодел и т.п.. Виды называются так же как и представляющая их нода + List или Full и могут быть переделаны из полученных сгенерированных форм, которые, в свою очередь, будут выгружаться в файл если ключ needCollect в настройках задан как true

Также имеется некоторое количество служебных видов, реализованных в виде qml-файлов:

* FullImageInfo.qml - полная информация о изображении

* FilterDialog.qml - служебная форма для фильтрации

# Хранение информации

Хранение информации реализовано в виде папки на диске со следующей структурой:

```
├───attachment
│   ├───note1.pdf
│   └───note2.doc
├───images
│   ├───1.bmp
│   └───2.jpg
├───forms
├───languages
│   └───ru_RU.json
├───base.sqlite
├───about.html
└───struct.json
```

**attachment** - папка с вложениями, вложения могут быть любыми (с оговоркой что хорошо бы что-то не слишком экзотическое чтобы со временем сделать экспорт) и открываются во внешних программах. Назначение данной сущности - нечто наподобие заметок, например, статья как отличать монеты Елизаветы разных дворов друг от друга или скан заключения ГИМа. Возможно, со временем будет возможность делать ко множеству сущностей (типов-вариантов) одно вложение

**images** - папка с картинками, в целом аналогичны вложениям (как видно из диаграмы, таблицы в базе имеют одинаковую структуру), но будут показываться прямо в программе. В качестве идентификатора в таблице и имени будет md5-сумма файла

**forms** - папка с файлами qml, в которых лежат подготовленные заранее формы

**languages** - папка с переводами. Не то чтобы я пытался замахнуться на продукт с международным использованием, просто проще всего сматчить названия полей в таблице на английском прямо в название полей в интерфейсе чем делать отдельно подписи и следить чтобы ничего не перепуталось.

**base.sqlite** - основное хранилище данных, база sqlite

**struct.json** - заданет связи таблиц друг с другом и некоторые другие нужные для ГУЯ вещи (откуда брать данные для комбобоксов, что выводить в списке и т.п.). Причина появления - хотелось менять некоторые параметры без перекомпиляции программы

**about.html** - описание таблицы для диалога about, причина появления - хотелось где-то сохранить откуда я надергал данных для базы + возможность прямо из программы посмотреть что это за версия базы


#struct.json

struct.json - это файл конфигурации конкретной базы данных, который задет внешний вид таблиц, записей и переходы между ними. 

В корне находятся следующие поля:

*name - название БД, которое будет отображаться в различных местах.
*startTable - имя ноды с которой будет начато отображение
*nodes - массив нод, структуру элемента подробнее смотри ниже

##Описание ноды в struct.json

Описание ноды включает  в себя следующие поля:
*name - имя ноды, используется как идентификатор
*usesUUIDs - флаг нужно ли генерить поле id с ууидом при вставке новой записи, если он не определен поле будет генериться
*sortColumn - поле по которому будет сортироваться таблица при выборке
*listModel - имя модели отображаемой в списке всех записей, введено чтобы можно было в качестве такой модели использовать представление (view), например, добавив в него поле есть ли тип в коллекции сгенеренное автоматом из конкретных монет
*listViewFields - массив полей отображающиеся в списке, в данный момент считается что все поля чисто текстовые
*childNode - массив дочерних нод, описывается в виде имя ноды и как названо поле id в дочерней ноде (оно там является внешним ключем)
*subNodes - массив сабнот, полностью идентичен по описанию childNode, отличается только отображение. В данный момент не задействовано и скорее всего когда буду (если буду) задействовать солью их с childNodes путем добавления поля isSubnode в элементы массива
*fullFormFields - список полей, отображаемых в полном виде записи. Структура элемента - имя поля из таблицы, тип поля и необходимые для отображения данные. В данный момент есть всего два типа полей - просто текст и комбобокс, у второго есть еще поле query описывающее какой запрос нужно задействовать для получения списка значений в подстановку
*hasImages и hasNotes - определяет могут ли быть у данной ноды картинки и записи

#python_utils

Данная папка в проекте содержит в себе некоторые служебные скрипты на питоне, в которых реализована некая функциональность, не требующаяся в самой программе. А именно:
* CVBAPI - биндинг к базе (пока не реализованно), содержит классы соотвествующие полям в базе (реализуются по мере надобности)
* csvToBase.py - преобразование из таблицы csv в базу, по сути служебный скрипт чтобы перегонять из эксель-подобных програм в базу. Нужна на этапе заполнения
* createVariationBase.py - создание базы разновидностей с нуля
* exportToMD.py - экспорт данных в markdown файл который потом можно преобразовать в html с помощью pandoc
* VariationBaseData - папка содержащая часть данных для создания с нуля базы разновидностей
* createCurrentCoinsBase.py - создание базы конкретных монет с нуля
* IndividualCoinsDataBase - папка содержащая часть данных для создания с нуля базы конретных монет (не по разновидностям)

Планируется реализовать в дальнейшем:
*экспорт в различные форматы только для чтения (pdf, форматы электронных книг, возможно, статический html)
*парсинг некоторых сайтов (по coins.su, работают не на 100% т.к. по сути там заполненые от руки посты и они далеко не всегда удовлетворяют одному и тому же шаблону, быстрее было вручную пробежаться и поправить все несоответствия)