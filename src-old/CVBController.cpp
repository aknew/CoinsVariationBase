#include "CVBController.h"
#include "CVBUtils.h"
#include "CVBTranslator.h"
#include <QQmlContext>
#include <QtWidgets/QApplication>
#include <QtWidgets/QMessageBox>
#include <QClipboard>

const QString kSettingBasePath="global/base";
const QString kSettingCollectAutogenerated="global/needCollect";


void CVBController::start(){
    QString basePath;
    QSettings settings("settings.ini",QSettings::IniFormat);
    settings.setIniCodec("windows-1251");

    basePath=settings.value(kSettingBasePath,"").toString();

    if (basePath.isEmpty()){
        QMetaObject::invokeMethod(this->applicationWindow,
                                  "openBase"
                                  );
    }
    else {
        try {
            this->openBase(basePath);
        }
        catch (...) {
            QMetaObject::invokeMethod(this->applicationWindow,
                                      "openBaseAlert"
                                      );
        }
    }

}

void CVBController::openBase(QString basePath){


    QSettings settings("settings.ini",QSettings::IniFormat);
    settings.setIniCodec("windows-1251");
    settings.setValue(kSettingBasePath,QVariant(basePath));

    QVariant var = settings.value(kSettingCollectAutogenerated,false);
    bool needCollect = var.toBool();

    this->applicationWindow->setProperty("needCollect", var);

    if (baseProvider) {
        /*
         This will be dropping any base specifics, but now we can't load another base so this if is empty
         */

        delete baseProvider;
    }

    CVBFromQmlFilePath(&basePath);
    basePath=basePath.append("/");
    baseProvider=new CVBBaseProvider(basePath,this);

    this->connect(baseProvider,SIGNAL(newTableWidget()),this,SLOT(newTableWidget()));
    this->connect(baseProvider,SIGNAL(getError(QString)),this,SLOT(showError(QString)));

    engine->addImageProvider(QLatin1String("imageProvider"),baseProvider->imageProvider);

    engine->rootContext()->setContextProperty("window",this);

    QString locale = QLocale::system().name();
    QString filename = QString("languages/") + locale+".json";

    static CVBTranslator translator;
    // FIXME: need get it from keys
    translator.m_needCollect = needCollect;
    if( translator.load(filename, basePath) ){
        QApplication::instance()->installTranslator(&translator);
        //QTextCodec::setCodecForTr(QTextCodec::codecForName("utf8"));
        qDebug() << "Translation file loaded" << filename;
    } else
        qDebug() << "Translation file not loaded:" << filename << "  dir:"<<basePath;

    baseProvider->startLevel();
}

void CVBController::showError(QString str){
    QMessageBox::critical(NULL, "", str);
}

void CVBController::addViewToStack(const QQuickView* view){
    QVariant newItem =QVariant::fromValue(qobject_cast<QQuickItem *>(view->rootObject()));

    QMetaObject::invokeMethod(this->stackView,
                              "push",
                              Q_ARG(QVariant,newItem)
                              );
}

void CVBController::removeWidgetFromStack(){

    int previousItemNumber = this->stackView->childItems().count()-2;

    QQuickItem *previousItem = this->stackView->childItems().at(previousItemNumber);

    QMetaObject::invokeMethod(this->stackView,
                              "pop",
                              Q_ARG(QVariant,QVariant::fromValue(previousItem))
                              );
    currentWidgetType.pop();
}

QQuickItem * CVBController::currentItem(){

    QVariant returnedValue=this->stackView->property("currentItem");

    return returnedValue.value<QQuickItem *>();
}

QStringList CVBController::listForName(const QString& name){
    return baseProvider->listForID(name);
}

void CVBController::newTableWidget(){
    QString str=baseProvider->basePath+baseProvider->currentNode()->listFormName();


    if (QFile::exists(str)){
        str = QString("file:///%1").arg(str);
        QMetaObject::invokeMethod(this->applicationWindow,
                                  "loadForm",
                                  Q_ARG(QVariant,str)
                                  );
    }
    else
    {
        QMetaObject::invokeMethod(this->applicationWindow,
                                  "createListForm"
                                  );
    }

    currentWidgetType.push(QMLListWithoutEditing);
}

void CVBController::fullInfo(int index){

    baseProvider->currentNode()->selectItemWithIndex(index);

    QString str=baseProvider->basePath+"forms/"+baseProvider->currentNode()->fullFormName();

    if (QFile::exists(str)){

        str = QString("file:///%1").arg(str);

        QMetaObject::invokeMethod(this->applicationWindow,
                                  "loadForm",
                                  Q_ARG(QVariant,str)
                                  );
    }
    else {
        QMetaObject::invokeMethod(this->applicationWindow,
                                  "createFullInfoForm"
                                  );
    }
    currentWidgetType.push(FullForm);
}
void CVBController::saveListForm(const QString& qmlString){
    QString filePath=baseProvider->basePath+"forms/"+baseProvider->currentNode()->listFormName();
    CVBSaveStringToFile(qmlString,filePath);
}

void CVBController::saveFullForm(const QString& qmlString){
    QString filePath=baseProvider->basePath+"forms/"+baseProvider->currentNode()->fullFormName();
    CVBSaveStringToFile(qmlString,filePath);
}

void CVBController::showFullScreenImage(QString imgSource){

    QQuickView *w=newDeclarativeView();
    w->rootContext()->setContextProperty("imgSource",imgSource);
    w->setSource(QUrl("qrc:/CVBControls/BigImage.qml"));

    this->addViewToStack(w);
    currentWidgetType.push(FullScreenImage);
}

QQuickView *CVBController::newDeclarativeView(){

    QQuickView *w=new QQuickView();
    w->setResizeMode(QQuickView::SizeRootObjectToView);
    w->engine()->addImageProvider(QLatin1String("imageProvider"),baseProvider->imageProvider);
    w->rootContext()->setContextProperty("window",this);
    return w;
}

void CVBController::needPopCurrentNode(){
    baseProvider->previousLevel();
}

void CVBController::addNewRecord(){
    newRowInsertion=true;

    if (currentWidgetType.top()==QMLListWithoutEditing){
        this->fullInfo(CVBSqlNode::kNewRowIndex);
    }
    else{
        CVBSqlNode *node = baseProvider->currentNode();
        node->selectItemWithIndex(CVBSqlNode::kNewRowIndex);
        QQuickItem *item = this->currentItem();
        item->setProperty("selectedItem",node->selectedItem());
    }
    this->baseProvider->beginTransaction();
    this->currentItem()->setProperty("state","editable");
}

void CVBController::deleteCurrentRecord(){

    baseProvider->deleteCurrentRow();
    this->removeWidgetFromStack();
}

void CVBController::applyChanges(){
    qDebug()<<"try get property from qml \n";
    QVariant returnedValue;

    QMetaObject::invokeMethod(this->currentItem(), "collectData",
                              Q_RETURN_ARG(QVariant, returnedValue));

    QVariantMap returnedMap=returnedValue.toMap();

    if (!returnedMap.isEmpty()) {

        qDebug()<<returnedMap;

        baseProvider->currentNode()->model->setSelectedItem(returnedMap);
    }
    this->baseProvider->commit();
    this->currentItem()->setProperty("state","");
    newRowInsertion=false;
}

void CVBController::dropChanges(){
    if (newRowInsertion){
        this->removeWidgetFromStack();
    }
    else{
        this->currentItem()->setProperty("state","");
    }
    baseProvider->currentNode()->model->revertAll();
    this->baseProvider->rollback();
    newRowInsertion=false;
}

void CVBController::startEditRecord(){
    this->baseProvider->beginTransaction();
    this->currentItem()->setProperty("state","editable");
}

void CVBController::buttonPressed(int index){

    qDebug()<<index;
    baseProvider->pressedButton(index);
}

QVariant CVBController::loadNewImage(QString imagePath = NULL){

    QVariant returnVar = QVariant("-1");
    if (!imagePath.isEmpty()){

        CVBFromQmlFilePath(&imagePath);

        QFile file(imagePath);

        if (file.open(QIODevice::ReadOnly)){

            QByteArray byteArray = file.readAll();

            returnVar = QVariant(baseProvider->idForAttach(byteArray));
        }
    }
    else {
        QClipboard *clipboard = QApplication::clipboard();
        QPixmap pix = clipboard->pixmap();
        if (!pix.isNull()){

            QByteArray bArray;
            QBuffer buffer( &bArray );
            buffer.open( QIODevice::WriteOnly );
            pix.save( &buffer, "JPG" );

            returnVar=QVariant(baseProvider->idForAttach(bArray));
        }
    }

    return returnVar;
}

void CVBController::saveImage(QString imageId, QString imagePath = NULL){

    QSize size=QSize();
    QImage img = baseProvider->imageProvider->requestImage(imageId,&size,size);

    if (!imagePath.isEmpty()){

        CVBFromQmlFilePath(&imagePath);

        bool flag = img.save(imagePath);

        if (!flag){
            //try add .jpg and save
            img.save(imagePath.append(".jpg"));
        }
    }
    else {
        QClipboard *clipboard = QApplication::clipboard();
        clipboard->setImage(img);
    }
}

CVBSqlNode *CVBController::nodeWithName(const QString &name){
    return baseProvider->nodeWithName(name);
}

CVBSqlNode *CVBController::currentNode(){
    return baseProvider->currentNode();
}

